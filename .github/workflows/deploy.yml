name: Deploy Waterbot to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allows manual trigger from GitHub UI

jobs:
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    
    steps:
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Checkout code from repository
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v3
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Configure AWS credentials using secrets
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Login to Amazon ECR
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ”‘ Login to Amazon ECR
        id: login-ecr
        run: |
          aws ecr get-login-password --region us-east-1 | \
          docker login --username AWS --password-stdin ${{ secrets.ECR_REPOSITORY }}
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Build Docker image
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ³ Build Docker image
        run: |
          echo "Building Docker image..."
          docker build -t waterbot:dev .
          echo "âœ… Build complete!"
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Tag Docker image
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ·ï¸ Tag Docker image
        run: |
          echo "Tagging image with latest and commit SHA..."
          docker tag waterbot:dev ${{ secrets.ECR_REPOSITORY }}:latest
          docker tag waterbot:dev ${{ secrets.ECR_REPOSITORY }}:${{ github.sha }}
          echo "âœ… Tagged successfully!"
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Push Docker image to ECR
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸ“¤ Push to ECR
        run: |
          echo "Pushing images to ECR..."
          docker push ${{ secrets.ECR_REPOSITORY }}:latest
          docker push ${{ secrets.ECR_REPOSITORY }}:${{ github.sha }}
          echo "âœ… Push complete!"
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Deploy to ECS (force new deployment)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: ğŸš€ Deploy to ECS
        run: |
          echo "Triggering ECS deployment..."
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_SERVICE }} \
            --force-new-deployment \
            --region us-east-1
          echo "âœ… Deployment triggered!"
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Wait for deployment to complete
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: â³ Wait for deployment to complete
        run: |
          echo "Waiting for ECS service to stabilize..."
          echo "This may take 2-5 minutes..."
          echo ""
          echo "ğŸ“Š What's happening:"
          echo "  1. ECS creates 2 NEW tasks"
          echo "  2. NEW tasks start and become RUNNING"
          echo "  3. NEW tasks pass health checks"
          echo "  4. OLD tasks are stopped"
          echo "  5. Deployment completes with only NEW tasks"
          echo ""
          
          # CRITICAL: This command BLOCKS until deployment is stable
          # It polls ECS every 15 seconds checking:
          # - New tasks are RUNNING
          # - Old tasks are stopped
          # - Service is healthy
          # If deployment fails, this exits with error and workflow STOPS
          echo "â³ Actively checking ECS service status..."
          aws ecs wait services-stable \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ secrets.ECS_SERVICE }} \
            --region us-east-1
          
          # This line only runs if above command succeeds!
          echo ""
          echo "âœ… Deployment complete and healthy!"
          echo ""
          
          # Verify: Get actual task statuses to confirm
          echo "ğŸ“‹ Verifying final task status:"
          TASK_ARNS=$(aws ecs list-tasks \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service-name ${{ secrets.ECS_SERVICE }} \
            --desired-status RUNNING \
            --region us-east-1 \
            --query 'taskArns' \
            --output text)
          
          if [ -z "$TASK_ARNS" ]; then
            echo "âŒ ERROR: No running tasks found!"
            exit 1
          fi
          
          TASK_COUNT=$(echo "$TASK_ARNS" | wc -w | tr -d ' ')
          echo "  â€¢ Running tasks: $TASK_COUNT"
          
          # Get detailed status of running tasks
          TASK_STATUSES=$(aws ecs describe-tasks \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --tasks $TASK_ARNS \
            --region us-east-1 \
            --query 'tasks[].lastStatus' \
            --output text)
          
          echo "  â€¢ Task statuses: $TASK_STATUSES"
          
          # Verify all tasks are RUNNING
          for status in $TASK_STATUSES; do
            if [ "$status" != "RUNNING" ]; then
              echo "âŒ ERROR: Task status is $status (expected RUNNING)"
              exit 1
            fi
          done
          
          echo "  â€¢ âœ… All tasks verified: RUNNING and healthy!"
          echo ""
          echo "âœ… Safe to proceed with CloudFront invalidation!"
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Invalidate CloudFront cache
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: â˜ï¸ Invalidate CloudFront cache
        run: |
          echo "Creating CloudFront invalidation..."
          
          # Step 1: Create invalidation (like your first command)
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*" \
            --region us-east-1 \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "Invalidation ID: $INVALIDATION_ID"
          echo "âœ… Cache invalidation request created!"
          echo ""
          
          # Step 2: Wait and verify completion (like your second command)
          echo "â³ Waiting for invalidation to complete..."
          echo "This usually takes 30-60 seconds..."
          
          # Poll until status is "Completed"
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATUS=$(aws cloudfront get-invalidation \
              --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
              --id "$INVALIDATION_ID" \
              --region us-east-1 \
              --query 'Invalidation.Status' \
              --output text)
            
            echo "  â€¢ Check $((ATTEMPT + 1))/$MAX_ATTEMPTS: Status = $STATUS"
            
            if [ "$STATUS" = "Completed" ]; then
              echo ""
              echo "âœ… CloudFront cache invalidation completed!"
              break
            fi
            
            if [ $ATTEMPT -eq $((MAX_ATTEMPTS - 1)) ]; then
              echo "âš ï¸  Warning: Invalidation still in progress after $MAX_ATTEMPTS checks"
              echo "   Status: $STATUS"
              echo "   This is not critical - invalidation will complete in background"
              break
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            sleep 2
          done
          
          echo ""
          echo "ğŸ“‹ Final CloudFront status:"
          echo "  â€¢ Invalidation ID: $INVALIDATION_ID"
          echo "  â€¢ Status: $STATUS"
          echo "  â€¢ Distribution: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}"
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Success notification
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: âœ… Deployment successful
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ‰ DEPLOYMENT SUCCESSFUL!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Time: $(date)"
          echo "URL: https://azwaterbot.org"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
